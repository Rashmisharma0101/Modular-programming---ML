1. LogTransformer (safe log)
class LogTransformer (BaseEstimator, TransformerMixin):
    def __init__(self, column):
        self.column = column

    def fit(self, X, y = None):
        return self

    def transform(self, X):
        X_new = X.copy()
        safe = X_new[self.column].apply(lambda x: 0 if x < 0 else x)
        X_new[self.column + '_logged'] = safe.apply(lambda x: np.log1p(x))
        return X_new

2. class CategoryFrequencyEncoder(BaseEstimator, TransformerMixin):
         def __init__(self, column):
                self.column = column

         def fit(self, X, y = None):
                vc = X[self.column].value_counts(normalize = True)
                self.frequency = vc.to_dict()
                return self

         def transform(self, X):
                X_new = X.copy()
                X_new[self.column + '_freq'] = X_new[self.column].map(self.frequency)
                X_new[self.column + '_freq'] = X_new[self.column + '_freq'].fillna(0)
                return X_new
                
        
3. QuantileClipper
For numeric column:
clip values below 5th percentile to 5th percentile
Clip values above 95th percentile to 95th percentile
Compute quantiles in fit().

class   QuantileClipper(BaseEstimator, TransformerMixin):
         def __init__(self, column):
                self.column = column
                self.fifth = None
                self.ninetyfifth = None

         def fit(self, X, y = None):
                self.fifth = np.percentile(X[self.column], 5)
                self.ninetyfifth = np.percentile(X[self.column], 95)
                return self

         def transform(self, X):
                X_new = X.copy()
                X_new[self.column +'_clipped'] = np.clip(X_new[self.column], fifth, ninetyfifth)
                return X_new
                

4. MultiColumnImputer
Given a list of columns:
Numeric â†’ replace NaN with median
Categorical â†’ replace NaN with mode
Dynamic logic based on dtype.

import is_numeric_dtype
class MultiColumnImputer(BaseEstimator, TransformerMixin):
         def __init__(self, columns):
                self.columns = columns
                self.medians = {}
                self.modes = {}

         def fit(self, X, y = None):
                for col in self.columns:
                    if is_numeric_dtype(X[col]):
                        self.medians[col] = X[col].median()
                    else:
                        self.modes[col] = X[self.col].mode().iloc[0]
                return self

         def transform(self, X):
                X_new = X.copy()
                for col in self.columns:
                    if col in self.medians:
                        X_new[col + '_imputed'] = X_new[col].fillna(self.medians[col])
                    else:
                        X_new[col + '_imputed'] = X_new[col].fillna(self.modes[col])
                
                return X_new

5ï¸âƒ£ ConditionalFlagger
Create a new column:
flag = 1 if (col1 > mean(col1)) AND (col2 < median(col2)) else 0
You must compute mean and median in fit().

class ConditionalFlagger(BaseEstimator, TransformerMixin):
         def __init__(self, column1, column2):
                self.column1 = column1
                self.column2 = column2
         def fit(self, X, y = None):
                self.mean = X[self.column1].mean()
                self.median  = X[self.column2].median()
                return self
         def transform(self, X):
                X_new = X.copy()
                X_new[self.column1 + self.column2 + '_flagged'] = (
(X_new[self.column1] > self.mean)  & (X_new[self.column2] < self.median)).astype(int)
                return X_new


6. InteractionFeatureCreator
Given two columns col1, col2, create:
col1 * col2
col1 + col2
col1 - col2
col1 / (col2 or NaN)
Safe division required.

class InteractionFeatureCreator(BaseEstimator, TransformerMixin):
         def __init__(self, column1, column2):
                self.column1 = column1
                self.column2 = column2
         def fit(self, X, y = None):
                return self
         def transform(self, X);
                X_new = X.copy()
                X_new[self.column1 + self.column2 +  '_multiply'] = X_new[self.column1] * X_new[self.column2]
                X_new[self.column1 + self.column2 + '_add'] = X_new[self.column1] + X_new[self.column2]
                X_new[self.column1 + self.column2 + '_subtract'] = X_new[self.column1] - X_new[self.column2]
                X_new[self.column1 + self.column2 + '_divide'] = X_new[self.column1] / X_new[self.column2].replace(0, np.nan)
                return X_new


7 MultiValueSplitter
Column contains strings like:
"apple, mango, banana"
Create:
word count
first item
boolean column: keyword present ("banana")

class MultiValueSplitter(BaseEstimator, TransformerMixin):
         def __init__(self, column, keyword = 'banana'):
                self.column = column
                self.keyword = keyword

         def fit(self, X, y = None):
                return self
         
        def transform(self, X):
                split_col = X_new[self.column].fillna("").apply(lambda x: [i.strip() for i in x.split(",") if i.strip()])
                # Word count
                X_new[f"{self.column}_wordcount"] = split_col.apply(len)

                # First item (or NaN)
                X_new[f"{self.column}_firstitem"] = split_col.apply(lambda lst: lst[0] if len(lst) > 0 else np.nan)
        
                # Keyword presence â†’ boolean flag
                X_new[f"{self.column}_flagged"] = split_col.apply(lambda lst: 1 if self.keyword in lst else 0)
                
8. PercentileRankEncoder
For numeric column:
Convert each value to percentile rank between 0â€“1.
Use scipy.stats.rankdata or implement manually.

class PercentileRankEncoder(BaseEstimator, TransformerMixin):
         def __init__(self, column):
                self.column = column
        
         def fit(self, X, y = None):
                self.values = X[self.column].values
                return self

        def transform(self, X):
        X_new = X.copy()
        col = X_new[self.column].values

        ranks = np.argsort(np.argsort(self.values))
        percentile_map = ranks / (len(self.values) - 1)

        # Create mapping value â†’ percentile
        mapping = dict(zip(self.values, percentile_map))

        # Apply mapping (handle unseen values safely)
        X_new[self.column + "_percentile_rank"] = (
            X_new[self.column].map(mapping).fillna(0.0)
        )

        return X_new

9 RollingWindowMean (advanced)
Given a numeric column:
value â†’ mean of last 3 values
But:
Must work on dataframe row-by-row
Should NOT use .rolling() inside transform
(rolling must be computed in fit, not transform)
ðŸ’¡ This tests: stateful transforms.

ðŸ”Ÿ TargetMedianEncoder (Category â†’ median of y)
Like mean encoder, but instead compute median of y for each category.
Also:Unseen categories in transform â†’ assign global median of y.    

class TargetMedianEncoder(BaseEstimator, TransformerMixin):
    def __init__(self, column):
        self.column = column
        self.median_counts = None
        self.global_median = None

    def fit(self, X, y):
        self.median_counts = X.groupby(self.column)[y.name].median()
        self.global_median = y.median()
        return self

    def transform(self, X):
        X_new = X.copy()
        X_new[self.column + '_median_encoded'] = X_new[self.column].map(median_counts)
        X_new[self.column + '_median_encoded'].fillna(self.global_median, inplace = True)
        return X_new
