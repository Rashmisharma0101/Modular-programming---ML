1. MissingCategoryImputer
If a column is categorical, replace missing values with the most frequent category.

class MissingCategoryImputer(BaseEstimator, TransformerMixin):
    def __init__(self, column, topn = 1):
      self.most_freq  = None
      self.column =  column
      self.topn = topn     

    def fit(self, X, y= None):
        self.most_freq = X[self.column].value_counts().nlargest(self.topn).index[0]
        return self

    def transform(self, X):
        X_new = X.copy()
        X_new[self.column] = X_new[self.column].fillna(self.most_freq)
        return X_new

2. RareCategoryGrouper
class RareCategoryGrouper(BaseEstimator, TransformerMixin):
        def __init__(self, column, threshold = 200):
            self.threshold = threshold
            self.column  = column

        def fit(self, X, y= None):
            value_counts   = X[self.column].value_counts()
            self.rarelist = value_counts[value_counts < self.threshold].index.tolist()
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column + "grouped"] = X_new[self.column].apply(lambda x: "other" if x in self.rarelist else x)
            return X_new

3. OutlierClipper
import numpy as np
class OutlierClipper(BaseEstimator, TransformerMixin):
    def __init__(self, column):
        self.mean = None
        self.column = column
        self.lower = None
        self.upper = None

    def fit(self, X, y = None):
        self.lower = np.percentile(X[self.column], 0.01)
        self.upper = np.percentile(X[self.column], 0.99)
        return self

    def transform(self, X):
        X_new = X.copy()

        def f1(x):
            if x < self.lower:
               return self.lower
            elif x> self.upper:
               return self.upper
            else:
               return x


        X_new[self.column + "_clipped"] = X_new[self.column].apply(f1)
        return X_new

alternate way 
def transform(self, X):
        X_new = X.copy()
        X_new[self.column + "_clipped"] = X_new[self.column].apply(
            lambda x: 
                self.lower if x < self.lower else 
                self.upper if x > self.upper else 
                x
        )
        return X_new

easiest way

X_new[self.column + "_clipped"] = X_new[self.column].clip(self.lower, self.upper)

4. ZScoreStandardizer
class ZScoreStandardizer(BaseEstimator, transformerMixin):
        def __init__(self, column):
            self.column = column

        def fit(self, X, y = None):
            self.mean = X[self.column].mean()
            self.std = X[self.column].std()
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column + "_standardized"] = (X_new[self.column] - self.mean)/self.std
            return X_new
            
    Leaarning

You do not need to initialize self.mean = None or self.std = None in __init__() because Python does NOT require "variable declarations" like C, C++, or Java.

In Python:

Attributes can be created anytime, not only inside __init__.

The attribute becomes part of the object the moment you assign it.

üß† The Real Rule You Need to Understand
‚úî You ONLY put in __init__() things that:

are hyperparameters

are given by the user

are not dependent on data

Examples:

column

top_n

threshold

impute_value

These belong in __init__().

‚ùå You should NOT put in __init__() things like:

mean
std
most_frequent_category
lower_limit
upper_limit

5. BooleanFlagFromWords

class BooleanFlagFromWords(BaseEstimator, TransformerMixin):
        def __init__(self, column, keywords = ['free', 'discount']):
            self.column = column
            self.keywords = keywords

        def fit(self, X, y = None):
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column + "_flagged"] = X_new[self.column].apply(lambda x : 1 if x in self.keywords else 0)
            return X_new
            

6. BinaryBinner
For numeric column, create bins:
values < threshold ‚Üí 0
values >= threshold ‚Üí 1
Requirement: threshold computed as median during fit.

class BinaryBinner(BaseEstimator, TransformerMixin):
        def __init__(self, column):
            self.column = column

        def fit(self, X, y = None):
            self.threshold = X[self.column].median()
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column + "_binned"] = X_new[self.column].apply(lambda x : 0 if x < self.threshold else 1)
            return X_new

7. ZeroToMissingConverter
Convert all 0 values in a numeric column to NaN.

class ZeroToMissingConverter(BaseEstimator, TransformerMixin):
        def __init__(self, column):
            self.column = column

        def fit(self, X, y = None):
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column + '_new'] = X_new[self.column].replace(0, np.nan)
            return X_new

8 GroupMeanEncoder
For a categorical column, compute the mean of target y for each category.
Requirements:
In fit(): compute category ‚Üí mean mapping.
In transform(): map categories to their mean

class GroupMeanEncoder(BaseEstimator, TransformerMixin):
        def __init__(self, column):
            self.column = column

        def fit(self, X, y = None):
            self.category_target_mean = X.groupby([self.column])[self.y].mean()
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column + '_mapped']  = X_new[self.column].map(self.category_target_mean)
            return X_new

‚ö† Good interviewer question!

9Ô∏è‚É£ RatioFeatureCreator
Given two numeric columns col1 and col2, create a new col = col1 / col2.
Must handle division-by-zero safely.

class RatioFeatureCreator(BaseEstimator, TransformerMixin):
        def __init__(self, column1, column2):
            self.column1 = column1
            self.column2 = column2

        def fit(self, X, y = None):
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new[self.column1 + "_" + self.column2]  = X_new[self.column1] / X_new[self.column2]
            return X_new

10. DateFeatureExtractor
Given a datetime column, extract:
year
month
day
weekday

import datetime
class DateFeatureExtractor(BaseEstimator, TransformerMixin):
        def __init__(self, column):
            self.column = column

        def fit(self, X, y = None):
            return self

        def transform(self, X):
            X_new = X.copy()
            X_new['year'] = X_new[column].dt.year
            X_new['month'] = X_new[column].dt.month
            X_new['day'] = X_new[column].dt.day
            X_new['weekday'] = X_new[column].dt.weekday
            return X_new

            
            
